You are an excellent smart contract vulnerability detector. Analyze the given smart contract code provided after [Solidity Code] tag, written in solidity. Determine (a) Is the contract vulnerable? (yes or no) and (b) If Yes, specify the vulnerability type (eg. Reentrancy, Arithmetic, etc.)

Let's go through the process step-by-step:
            
            1. Code Review: Read through the contract code carefully.
            2. Identify Vulnerabilities: Look for vulnerability types like 
              "UNCHECKED_LL_CALLS":- The term "UNCHECKED_LL_CALLS" refers to low-level calls (e.g., call, send, delegatecall) that do not check for success. Severity: High.
              "ARITHMETIC":- Issues like overflow and underflow in mathematical operations. Severity: High.
              "DENIAL_OF_SERVICE":-Contract can be made unusable, typically through gas limit exhaustion. Severity: High.
              "REENTRANCY":- A function that interacts with an external contract and changes state afterward, allowing the external contract to call back into the original function and              manipulate state. Severity: High.
              "time_manipulation":-Exploiting block timestamps for conditional operations. Severity: Medium.
              "BAD_RANDOMNESS":-Using block data or other predictable sources for randomness. Severity: Medium.
              "unsafe_suicide":-Using selfdestruct to kill the contract without proper checks. Severity: High.
              "ACCESS_CONTROL":-Insufficient checks on functions that should be restricted to certain roles. Severity: High.
              "tx.origin":-Using tx.origin for authorization can be exploited in phishing attacks. Severity: Medium.
              "unsafe delegatecall":-Using delegatecall improperly can lead to execution of malicious code. Severity: Medium.
              "Gasless_Send":-Using send instead of transfer, which might not provide enough gas for the receiving contract. Severity: High.
              "OTHER - uninitialized storage":-Uninitialized storage variables can lead to unexpected behavior. Severity: High
              "FRONT_RUNNING":-An attacker can observe a transaction and react to it by sending a transaction with higher gas. Severity: High.
            
            
            Example Walkthrough:
            
            [Solidity Code]:
            
            
            pragma solidity ^0.4.19; contract ETH_FUND { mapping (address => uint) public balances; uint public MinDeposit = 1 ether; Log TransferLog; uint lastBlock; function ETH_FUND(address _log) public { TransferLog = Log(_log); } function Deposit() public payable { if(msg.value > MinDeposit) { balances[msg.sender]+=msg.value; TransferLog.AddMessage(msg.sender,msg.value,"Deposit"); lastBlock = block.number; } } function CashOut(uint _am) public payable { if(_am<=balances[msg.sender]&&block.number>lastBlock) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,"CashOut"); } } } function() public payable{} } contract Log { struct Message { address Sender; string Data; uint Val; uint Time; } Message[] public History; Message LastMsg; function AddMessage(address _adr,uint _val,string _data) public { LastMsg.Sender = _adr; LastMsg.Time = now; LastMsg.Val = _val; LastMsg.Data = _data; History.push(LastMsg); } }
            
            Step-by-Step Analysis:
            
            1. Code Review: 
               - The contract allows buying tokens, changing the token price, changing the active status, and withdrawing Ether.
               - Vulnerability Line: if(msg.sender.call.value(_am)())
               - Vulnerable Functions: CashOut(uint _am)
               - Fallback function: Calls CashOut(uint _am) when Ether is sent to the contract.

            2. Identify Vulnerabilities:
               - UNCHECKED_LL_CALLS:Not applicable.
               - ARITHMETIC:Not applicable.
               - DENIAL_OF_SERVICE:Not applicable.
               - REENTRANCY: CashOut function: Ether is sent before the state change, making it vulnerable to reentrancy attacks. A function that interacts with an external contract and changes state afterward, allowing the external contract to call back into the original function and manipulate state. 
               - TIME_MANIPULATION: Not applicable.
               - BAD_RANDOMNESS: Not applicable.
               - UNSAFE_SUICIDE: Not applicable.
               - ACCESS_CONTROL:Not applicable.
               - TX.ORIGIN: Not applicable.
               - UNSAFE_DELEGATECALL: Not applicable.
               - GASLESS_SEND: Not applicable.
               - OTHER - UNINITIALIZED_STORAGE: Not applicable.
               - FRONT_RUNNING: Not directly applicable.
            
            Your Answer:
            (Vulnerability: Yes, Vulnerability Type: REENTRANCY)
            
            Now analyze the following contract:
            
            [Solidity Code] <code-snippet> 

